<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>V4 – LP Mood Wheel (cursor-based speed)</title>
  <style>
    html, body { height:100%; margin:0; background:#0d0f15; overflow:hidden; }
    #c { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// =====================================================
// V4 – LP Mood Wheel (Cursor-based speed control)
// -----------------------------------------------------
// - 도넛은 항상 화면 중앙에 고정되어 회전만 수행함
// - 기본 회전은 느긋하게 유지 (기존 속도)
// - 커서가 중앙 라벨에 가까워질수록 빠르게 회전 (색이 섞여보일 정도)
// - 중앙부에서 멀어질수록 점진적으로 기본속도로 복귀
// - 도넛 밖으로 커서가 나가면 기본 회전 속도로 복귀
// =====================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let dpr = window.devicePixelRatio || 1;
let W, H;
function fit(){
  W = canvas.width = window.innerWidth * dpr;
  H = canvas.height = window.innerHeight * dpr;
}
window.addEventListener('resize', fit);
fit();

const DEG = Math.PI / 180;
let baseSpeed = 30 * DEG; // 기본 회전속도 (느긋한 회전)
let angle = 0;            // 현재 회전각
let pointer = {x: Infinity, y: Infinity}; // 마우스 위치 저장

// 마우스 이동 감지
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  pointer.x = (e.clientX - rect.left) * dpr;
  pointer.y = (e.clientY - rect.top) * dpr;
});
canvas.addEventListener('mouseleave', () => {
  pointer.x = Infinity;
  pointer.y = Infinity;
});

// 랜덤 색상 10개 생성
function randomColor(){
  const h = Math.floor(Math.random() * 360);
  const s = 60 + Math.random() * 30;
  const l = 55 + Math.random() * 10;
  return `hsl(${h}, ${s}%, ${l}%)`;
}
const colors = Array.from({length:10}, randomColor);
const date = '2025-10-30';

function loop(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#0d0f15';
  ctx.fillRect(0,0,W,H);

  const cx = W/2, cy = H/2;
  const outerR = Math.min(W,H)*0.38;
  const labelRatio = 0.27; // 중앙 라벨 크기 비율
  const innerR = outerR * labelRatio;

  // === 커서 거리 기반 회전속도 조절 ===
  let factor = 1.0;
  if (isFinite(pointer.x) && isFinite(pointer.y)) {
    const dx = pointer.x - cx;
    const dy = pointer.y - cy;
    const dist = Math.hypot(dx, dy);
    if (dist <= innerR) {
      factor = 25.0; // 중앙에 가까울수록 빠르게 (최대 25배)
    } else if (dist < outerR) {
      // 중앙~도넛 사이: 선형적으로 감소
      const t = (dist - innerR) / (outerR - innerR);
      factor = 3.0 - 2.0 * t; // 중앙3배 → 외곽1배로 선형 변화
    } else {
      factor = 1.0; // 도넛 밖에서는 기본속도
    }
  }

  angle += (baseSpeed * factor) / 60; // 회전속도 반영

  // === 도넛 그리기 ===
  ctx.save();
  ctx.translate(cx, cy); // 중심 고정
  ctx.rotate(angle);

  const n = colors.length;
  const slotAng = (Math.PI*2)/n;

  // 도넛 배경
  donutArc(innerR, outerR, 0, Math.PI*2, '#10131d');

  // 각 색상 균등 분할
  for(let i=0;i<n;i++){
    const a0 = i * slotAng;
    const a1 = a0 + slotAng;
    donutArc(innerR, outerR, a0, a1, colors[i]);
  }

  ctx.restore();

  // === 중앙 라벨 ===
  ctx.save();
  ctx.translate(cx, cy);
  ctx.beginPath();
  ctx.arc(0,0, innerR*0.98, 0, Math.PI*2);
  ctx.fillStyle = '#1a1e29';
  ctx.fill();
  ctx.fillStyle = '#cfd5ff';
  ctx.font = `${Math.max(12, Math.round(innerR*0.20))}px system-ui`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(date, 0, -innerR*0.10);

  const top3 = [...colors].sort(()=>Math.random()-0.5).slice(0,3);
  const size = innerR*0.095; const gap = size*0.5;
  let x = - (top3.length-1)*(size+gap)/2;
  const y = innerR*0.18;
  for(const c of top3){
    ctx.beginPath();
    ctx.arc(x,y,size,0,Math.PI*2);
    ctx.fillStyle = c;
    ctx.fill();
    x += size+gap;
  }
  ctx.restore();

  requestAnimationFrame(loop);
}

function donutArc(r0, r1, a0, a1, color){
  ctx.beginPath();
  ctx.arc(0, 0, r0, a0, a1, false);
  ctx.arc(0, 0, r1, a1, a0, true);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
}

requestAnimationFrame(loop);
</script>
</body>
</html>